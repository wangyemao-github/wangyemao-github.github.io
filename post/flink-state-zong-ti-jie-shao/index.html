<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Flink State 总体介绍 | Gridea</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://wangyemao-github.github.io/favicon.ico?v=1609230775237">
<link rel="stylesheet" href="https://wangyemao-github.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="本文主要对Flink State进行整体介绍，包括

一、有状态流计算介绍
什么是有状态的计算
计算任务的结果不仅仅依赖于输入，还依赖于它的当前状态。比如，很常见的业务场景wordCount，在计算的过程中要不断地把输入累加到count上去..." />
    <meta name="keywords" content="Flink" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://wangyemao-github.github.io">
        <img src="https://wangyemao-github.github.io/images/avatar.png?v=1609230775237" class="site-logo">
        <h1 class="site-title">Gridea</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://wangyemao-github.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Flink State 总体介绍</h2>
            <div class="post-date">2020-12-29</div>
            
            <div class="post-content" v-pre>
              <p>本文主要对Flink State进行整体介绍，包括</p>
<!-- more -->
<h1 id="一-有状态流计算介绍">一、有状态流计算介绍</h1>
<h2 id="什么是有状态的计算">什么是有状态的计算</h2>
<p>计算任务的结果不仅仅依赖于输入，还依赖于它的当前状态。比如，很常见的业务场景wordCount，在计算的过程中要不断地把输入累加到count上去，那么<strong>这里的count就是一个state</strong><br>
<img src="https://wangyemao-github.github.io/post-images/1609229474736.jpg" alt="" loading="lazy"><br>
Flink基于用户定义代码对到来的数据进行转换操作，处理过程中不仅依赖用户定义算子，还会涉及State数据的读写操作。这些State数据会存储在本地的State backend中，在Checkpoint的时候持久化到配置的Checkpoint 目录</p>
<h2 id="传统流式框架">传统流式框架</h2>
<p>此处主要针对实时计算框架—Spark进行对比。在Spark实时计算框架中，流式数据处理通过将源源不断的数据切分为一个个很小时间间隔的批块，流式计算实际上是一种微批计算，而不是真正意义上的流式处理。针对每一个微批，只需要保存微批计算的最终结果，因此它对于State的需求还是比较小的。</p>
<p>实际上，流式计算对State的要求是非常高的。因为流系统中输入是一个无限制的流，需要保证很长一段时间持续不间断运行，这个过程中就需要很好地将状态数据管理起来。传统的流式计算框架缺乏对State的有效支持：</p>
<ol>
<li>状态数据的存储和访问</li>
<li>状态数据的备份和恢复</li>
<li>状态数据的划分和动态扩容</li>
</ol>
<h2 id="flink提供了丰富的状态访问和高效的容错机制">Flink提供了丰富的状态访问和高效的容错机制</h2>
<ol>
<li>多种数据类型：Value、List、Map、Reducing、Folding、Aggregating</li>
<li>多种划分方式： Keyed State、Operator State</li>
<li>多种存储格式： MemoryStateBackend、FsStateBackend、RocksDBStateBackend</li>
<li>高效的备份和恢复：提供ExactlyOnce保证、增量及异步备份本地恢复</li>
</ol>
<h1 id="二-flink-state">二、Flink State</h1>
<p>根据Flink 状态数据的划分和扩张方式 将 State 分为：</p>
<ul>
<li>Operator State</li>
<li>Keyed State</li>
</ul>
<p>对比：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>Keyed State</th>
<th>Operator State</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否存在当前处理的 key（current key）</td>
<td>keyed state的value总是与一个current key对应。一个Operator实例处理多个key，访问相应的多个State</td>
<td>无当前key概念。一个Operator实例对应一个State</td>
</tr>
<tr>
<td>存储对象是否 on heap</td>
<td>keyed state backend 有on-heap和off-heap(RocksDB)的多种实现</td>
<td>目前operator state backend仅有一种on-heap的实现</td>
</tr>
<tr>
<td>是否需要手动声明快照(snapshot)和恢复（restore)方法</td>
<td>由backend自行实现，对用户透明</td>
<td>需要手动实现snapshot和restore方法</td>
</tr>
<tr>
<td>状态数据大小【这只是个经验判断，不是绝对的判断区分标准】</td>
<td>一般而言，Keyed state规模的相对比较大的</td>
<td>一般而言，我们认为operator state的数据规模是比较小的</td>
</tr>
<tr>
<td>使用场景</td>
<td>只能用于KeyedStream上的算子</td>
<td>可以用于所有的算子，常用于Source，例如FlinkKafkaConsumer</td>
</tr>
<tr>
<td>并发改变时State重分布</td>
<td>基于Key-Group，State随着Key在实例间迁移</td>
<td>并发改变时，有多种重新分配方式可选：均匀分配；合并后每个实例都得到全量状态</td>
</tr>
<tr>
<td>使用</td>
<td>通过RuntimeContext访问-----操作函数需要实现RichFunction接口</td>
<td>实现CheckpointedFunction或ListCheckpointed接口</td>
</tr>
<tr>
<td>支持数据接口</td>
<td>包括：ValueState、ListState、ReducingState、AggregatingState、MapState</td>
<td>ListState。----特别说明：Broadcast State 是MapState类型</td>
</tr>
</tbody>
</table>
<h1 id="三-flink-state存储和管理">三、Flink State存储和管理</h1>
<h2 id="state-backend-分类">State Backend 分类</h2>
<p>State在内部如何表述，checkpoint时，State如何以及在哪里进行持久化，依赖于选择的State Backend。Flink默认捆绑了三类State Backends：MemoryStateBackend、FsStateBackend、RocksDBStateBackend。在未配置的情况下，系统将默认使用MemoryStateBackend。</p>
<p><strong>详细区别：</strong></p>
<p><strong>关于RocksDBStateBackend的特别说明：</strong></p>
<ol>
<li>这种方式可以维持的状态量只受限于可用的磁盘空间。与FsStateBackend将state存储在内存相比，这种方式允许保留更大的state</li>
<li>但是，这也意味着，可以获取的最大吞吐量将比FsStateBackend方式的低</li>
<li>所有对backend的read/write都需要通过序列化/反序列化，以存储/获取状态对象。这种方式与基于堆的存储方式代价更高</li>
</ol>
<h2 id="state-backend配置">State Backend配置</h2>
<ul>
<li>配置默认State Backend</li>
</ul>
<blockquote>
<p>flink-conf.yml<br>
state.backend: 【可能的取值：jobmanager(MemoryStateBackend)、fileSystem(FsStateBackend)、rocksdb(RocksDBStateBackend)、或者实现了state backend factory StateBackendFactory的全限定类名（org.apache.flink.contrib.streaming.state.RocksDBStateBackendFactory）】<br>
state.checkpoints.dir:定义backend写快照数据和元数据文件的目录</p>
</blockquote>
<ul>
<li>per-job 设置State Backend</li>
</ul>
<blockquote>
<p>StreamExecutionEnvironment</p>
</blockquote>
<pre><code>StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
env.setStateBackend(new FsStateBackend(&quot;hdfs://namenode:40010/flink/checkpoints&quot;));
</code></pre>
<h1 id="四-flink-state-划分和动态扩容">四、Flink State 划分和动态扩容</h1>
<h2 id="state-划分">State 划分</h2>
<ul>
<li>对于Operator State类型，每一个并行的Operator实例对应一个State</li>
<li>对于Keyed State类型，每一个Current Key对应一个State</li>
</ul>
<h2 id="state-动态扩容">State 动态扩容</h2>
<p><strong>Operator State类型</strong></p>
<ul>
<li>ListState：并发度改变的时候，会将并发实例上的ListState都合并到一个新的List，然后均匀分配到并更后的并发Task上</li>
<li>UnionListState：每一个并发Task都会拿到全量的ListState</li>
<li>BroadcastState：每个并发Task上的State都是完全一致的，因此，当增大并发度时，只需要Copy一份State到新Task即可</li>
</ul>
<p><strong>Keyed State类型</strong><br>
在并行度改变时，如何重分布KeyedState数据，最直观的做法就是计算每个Key的Hash值，并基于并行度parallelism取余。下图为当并行度改变时，基于Hash取余算法的State数据重分布情况：</p>
<p>hash取余重分布算法存在的问题：之前在各个Task上维护好的State数据会根据新的并行度重新组织，State数据在各个Task之间传输。这对于KeyedState数据较大时，数据重新组织的代价会很高。</p>
<p>为了规避上述问题，Flink基于Key-Group(KeyedState的最小组织单位)组织、分配KeyedState。具体的映射关系为</p>
<pre><code>public static int assignToKeyGroup(Object key, int maxParallelism) {
   return computeKeyGroupForKeyHash(key.hashCode(), maxParallelism);
}
public static int computeKeyGroupForKeyHash(int keyHash, int maxParallelism) {
   return MathUtils.murmurHash(keyHash) % maxParallelism;
}
</code></pre>
<p>也就是说，Key-Group数量取决于最大并行度（MaxParallism），只要最大并行度不变，同一个key归属的Key-Group是不会变更的。另外，此处在HashCode的基础上又调用murmurHash方法是为了保证尽量散列。</p>
<p>在对Key划分Key-Group之后，MaxParallism个Key-Group 基于KeyGroupRange分配到parallelism个并行Task中，每一个并行Task持有1个KeyGroupRange，具体计算方法：</p>
<pre><code>public static KeyGroupRange computeKeyGroupRangeForOperatorIndex(
   int maxParallelism,
   int parallelism,
   int operatorIndex) {
   int start = ((operatorIndex * maxParallelism + parallelism - 1) / parallelism);
   int end = ((operatorIndex + 1) * maxParallelism - 1) / parallelism;
   return new KeyGroupRange(start, end);
}
</code></pre>
<p><strong>以一个具体的实例说明：</strong><br>
对于一个Key 空间=[0,1,2,3,4,5,6,7,8,9] 的数据，MaxParallelism=5，并行度Parallelism由2扩大到3的过程中， 各个并行Task的Key-Group重分布情况为：</p>
<p><strong>总结：</strong></p>
<ol>
<li>只要MaxParallelism不变，整个Key空间的Key-Group划分情况是不会变更的</li>
<li>当并行度变更时，基于Key-Group，将Key-Group重新分配到并行Task中，并且这种重新分配不是一个Shuffle，Key-Group归属的并行Task的变更很小。</li>
</ol>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://wangyemao-github.github.io/tag/fz0w5SGEE/" class="tag">
                    Flink
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://wangyemao-github.github.io/post/hello-gridea/">
                  <h3 class="post-title">
                    Hello Gridea
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
